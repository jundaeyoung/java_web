# 기반지식_인코딩과포트?





**언어에서의 약속** 

문장의 의미는 문장을 구성하는 단어의 의미, 문법 구조, 맥락, 독자의 배경 지식 등으로 결정됩니다. 이 중 단어의 의미와 문법은 사회적으로 합의되어 있습니다.



**인코딩?**

컴퓨터의 모든 데이터는 0과 1로 구성됩니다. 지금 보고 있는 글도 사실은 0과 1의 집합입니다. “사과”가 사과를 가리키는 데 약속이 필요하듯, 0과 1로 우리의 문자를 표현하는 것도 일종의 약속 덕분입니다. 이런 약속들을 특별히 인코딩(Encoding) 표준이라고 부르는데, 대표적으로 아스키(Ascii)와 유니코드(Unicode)가 있습니다. 

아스키는 7비트 데이터에 대한 인코딩 표준입니다. 이를 이용하면 알파벳과 특수 문자 등을 표현할 수 있습니다. 예를 들어, 아스키에서 1 한 개, 0 다섯 개, 1 한 개를 이어 붙이면 “A”로 해석됩니다. 이에 따라 “1000001”이라는 데이터를 아스키로 변환하면 “A”가 됩니다.

컴퓨터가 개발된 초기에는 각 문자권마다 고유의 인코딩 표준을 사용했습니다. 영어는 아스키, 한글은 CP-949, EUC-KR 등을 사용했습니다. 그런데 이러한 방식은 호환성 측면에서, 국제 소프트웨어를 개발하려는 회사에 큰 부담이 됐습니다. 가끔 소프트웨어를 실행했을 때 글자가 🆡🆡🆡 등으로 출력되는 것이 인코딩이 호환되지 않아 발생하는 문제입니다.

이러한 어려움을 해결하고자 유니코드라는 새로운 표준이 만들어졌습니다. “Uni(하나의)”라는 접두사가 나타내듯, 유니코드는 모든 언어의 문자를 하나의 표준에 담겠다는 목표로 제정되었습니다. 유니코드에서 한 문자는 최대 32개의 비트로 표현됩니다. 32비트로 표현할 수 있는 정보의 가짓수는 2^{32}2 
32
 , 대략 42억 개입니다. 전 세계의 문자를 표현하고도 남을 넓은 공간입니다. 그래서 최근에는 한글, 한자, 히라가나, 가타카나, 알파벳과 같은 문자 외에 각종 이모지(Emoji)들도 유니코드에 포함되고 있습니다.😁

인코딩을 이용하면 우리의 문장을 컴퓨터에 저장하고, 표현할 수 있습니다. 그리고 네트워크를 이용하면 인코딩한 정보를 다른 사람들과 쉽게 교환할 수도 있습니다. 





### 💡네트워크 포트와 서비스 포트



네트워크 포트(Network Port)란 네트워크에서 서버와 클라이언트가 정보를 교환하는 추상화된 장소를 의미합니다. 포트에는 항구라는 의미가 있는데, 클라이언트가 서버의 포트에 접근하여 데이터를 내려놓고, 서버가 클라이언트에 보낼 데이터를 실어서 돌려보내는 장면을 연상하면 포트의 기능을 이해할 수 있습니다. 편의상, 네트워크를 설명하는 맥락에서는 네트워크를 생략하여 “포트”라고 부르기도 합니다.



서비스 포트(Service Port)는 네트워크 포트 중에서 특정 서비스가 점유하고 있는 포트를 이릅니다. 예를 들어, HTTP가 80번 포트를 점유하고 있다면 HTTP의 서비스 포트는 80번 포트가 됩니다.



포트로 데이터를 교환하는 방식은 전송 계층(Transport Layer)의 프로토콜을 따릅니다. 대표적으로는 TCP와 UDP가 있습니다.  TCP로 데이터를 전송하려는 서비스에 UDP 클라이언트가 접근하면, 데이터가 교환되지 않습니다. 반대의 경우도 마찬가지입니다. 그래서 서비스 포트를 표기할 때는 서비스가 사용하는 전송 계층 프로토콜을 같이 표기하기도 합니다. 예를 들어, HTTP의 서비스 포트가 TCP/80 이라고 하면, HTTP 서비스를 80번 포트에서 TCP로 제공하고 있다는 뜻입니다.

포트의 개수는 운영체제에서 정의하기 나름입니다. 그러나 현대의 윈도우나 리눅스, 맥 운영체제는 0번 부터 65535번까지, 총 65536개의 같은 수의 네트워크 포트를 사용합니다.

포트 중 0번부터 1023번 포트는 잘 알려진 포트(Well-known port) 또는 특권 포트(Privileged port)라고 합니다. 문자 그대로 각 포트 번호에 유명한 서비스가 등록되어 있습니다. 대표적으로 22번 포트에는 SSH, 80에는 HTTP, 443에는 HTTPS가 할당되어 있습니다. 잘 알려진 포트에 서비스를 실행하려면 관리자 권한이 필요합니다. 따라서 클라이언트는 이 대역에서 실행 중인 서비스들은 관리자의 것이라고 신뢰할 수 있습니다.




설명

HTTP 통신에 쓰이는 쿠키와 세션에 대해 설명합니다. 

| 키워드                                                       |
| ------------------------------------------------------------ |
| • Connectionless • Stateless • 쿠키 (Cookie) • 세션 (Session) • 세션 하이재킹 (Session Hijacking) |





목표

HTTP 통신에 쓰이는 쿠키와 세션에 대한 이해



서론

현대의 웹 서비스는 대부분 로그인을 통해 마이페이지, 유료 서비스 등 개인만의 서비스를 이용합니다. 웹 서버는 수많은 클라이언트와 HTTP 프로토콜을 사용해 통신합니다. 손님 계정으로 로그인 했다면 손님이 이용할 수 있는 서비스를 제공하고, 관리자 계정으로 로그인 했다면 데이터베이스, 회원 관리 등의 관리자 페이지를 제공해야 합니다.

그렇다면 웹 서버는 수많은 클라이언트를 어떻게 구별하고 서로 다른 결과를 반환해줄까요? HTTP 프로토콜로 웹 서버와 통신할 때에는 웹 서버에 명령을 내리기 위해 GET, POST와 같은 메소드와 자원의 위치를 가리키는 URL 등이 포함되어 있습니다. 이외에도 **헤더(Header)**를 통해서 웹 서버에게 요청을 보내고, 웹 서버는 헤더를 읽고 클라이언트에게 결과 값을 반환합니다. 이때, 헤더에는 클라이언트의 정보와 요청의 내용을 구체화하는 등의 데이터가 포함되는데, 클라이언트의 인증 정보 또한 포함될 수 있습니다.




### 통신 프로토콜이란?



웹 서버에 있는 리소스를 클라이언트가 받아 보려면, 클라이언트는 웹에게 특정 리소스를 지정하여 제공해달라고 요청해야 합니다. 그러면 서버가 해당 요청을 이해하고, 대응되는 동작을 통해 클라이언트에게 리소스를 반환합니다. 여기서 클라이언트의 행위를 요청(Request), 서버의 행위를 응답(Response)이라고 합니다.



요청과 응답은 우리의 일상에서도 빈번히 일어나는 상호작용입니다. 집에서, 가게에서, 회사에서 누군가에게 뭔가를 달라고 할 때는 항상 요청과 응답이 이뤄집니다. 눈여겨볼 점은 이러한 행위가 어느 정도 약속되어 있다는 것입니다. A에게 B를 요구할 때, “A야 B 좀 줘”라고 이야기하면, A가 B를 찾아서 건네줍니다. 상황에 따라 요청의 뉘앙스가 조금 바뀔 수는 있지만, 대개는 비슷합니다.



프로토콜(Protocol)은 위와 같이 규격화된 상호작용에 적용되는 약속을 이릅니다. 일상생활의 상호작용은 대부분 관습 또는 에티켓이라는 형태의 느슨한 프로토콜을 따릅니다. 통화할 때는 보통 “여보세요”로 시작해서 본론을 말하고 “끊어”, “바이” 등으로 통화를 끝맺습니다. 그런데 때에 따라서는 본론을 말하기 전에 서로 신원을 밝히거나, 아예 인사를 생략할 수 있습니다. 맥락을 아는 사람만 이해할 수 있는 애매한 표현을 사용할 수도 있습니다. 이처럼 일상에서 사람과 사람이 통신할 때는 관습을 따르되 약간의 융통성을 발휘해도 정보를 교환하는 데 큰 문제가 발생하지 않습니다.



반면, 컴퓨터와 통신할 때는 비교적 엄격한 프로토콜을 사용해야 합니다. 왜냐하면, 컴퓨터가 해석의 융통성을 발휘하게 하는 것은 매우 어렵고, 이 과정에서 오히려 통신 오류가 발생할 가능성을 높일 수 있기 때문입니다. 그래서 많은 컴퓨터 통신 프로토콜은 각 통신 주체가 교환하는 데이터(이하 메시지)를 명확히 해석할 수 있도록 문법(syntax)을 포함합니다. 일반적으로 이 문법에 어긋나는 메시지는 잘못 전송된 것으로 취급하여 무시됩니다. 예를 들어, 웹 서버에 “GET A”라고 보낼 것을 “GIVEME A”라고 보내면, “GET”과 “GIVEME”의 의미가 비슷하므로 A를 반환할 만하지만, 웹서버에서는 이를 오류로 처리합니다.



현재까지 제정된 표준 통신 프로토콜에는 네트워크 통신의 기초가 되는 TCP/IP, 웹 애플리케이션이 사용하는 HTTP, 파일을 주고받을 때 사용하는 FTP 등 매우 많은 종류가 있습니다.





### HTTP 통신은 Request 와 Response에 여행이다. 



```java
HTTP(Hyper Text Transfer Protocol)란 서버와 클라이언트의 데이터 교환을 요청(Request)과 응답(Response) 형식으로 정의한 프로토콜입니다. 팀 버너스 리(Team Berners-Lee)와 그의 팀이 제정한 이후, 현대 웹 서비스의 바탕이 되는 프로토콜로 자리 잡았습니다.

HTTP의 기본 메커니즘은 클라이언트가 서버에게 요청하면, 서버가 응답하는 것입니다. 웹 서버는 HTTP 서버를 HTTP 서비스 포트에 대기시킵니다. 이 포트는 일반적으로 TCP/80 또는 TCP/8080입니다. 클라이언트가 서비스 포트에 HTTP 요청을 전송하면, 이를 해석하여 적절한 응답을 반환합니다.

오른쪽 탭에는 요청과 응답의 예가 있습니다. 데이터 위에 마우스를 올리면, 각 필드에 대한 설명을 확인할 수 있습니다.

💡네트워크 포트와 서비스 포트

네트워크 포트(Network Port)란 네트워크에서 서버와 클라이언트가 정보를 교환하는 추상화된 장소를 의미합니다. 포트에는 항구라는 의미가 있는데, 클라이언트가 서버의 포트에 접근하여 데이터를 내려놓고, 서버가 클라이언트에 보낼 데이터를 실어서 돌려보내는 장면을 연상하면 포트의 기능을 이해할 수 있습니다. 편의상, 네트워크를 설명하는 맥락에서는 네트워크를 생략하여 “포트”라고 부르기도 합니다.

서비스 포트(Service Port)는 네트워크 포트 중에서 특정 서비스가 점유하고 있는 포트를 이릅니다. 예를 들어, HTTP가 80번 포트를 점유하고 있다면 HTTP의 서비스 포트는 80번 포트가 됩니다.

포트로 데이터를 교환하는 방식은 전송 계층(Transport Layer)의 프로토콜을 따릅니다. 대표적으로는 TCP와 UDP가 있습니다. 이들에 대한 설명은 부록에 있습니다. TCP로 데이터를 전송하려는 서비스에 UDP 클라이언트가 접근하면, 데이터가 교환되지 않습니다. 반대의 경우도 마찬가지입니다. 그래서 서비스 포트를 표기할 때는 서비스가 사용하는 전송 계층 프로토콜을 같이 표기하기도 합니다. 예를 들어, HTTP의 서비스 포트가 TCP/80 이라고 하면, HTTP 서비스를 80번 포트에서 TCP로 제공하고 있다는 뜻입니다.

포트의 개수는 운영체제에서 정의하기 나름입니다. 그러나 현대의 윈도우나 리눅스, 맥 운영체제는 0번 부터 65535번까지, 총 65536개의 같은 수의 네트워크 포트를 사용합니다.

포트 중 0번부터 1023번 포트는 잘 알려진 포트(Well-known port) 또는 특권 포트(Privileged port)라고 합니다. 문자 그대로 각 포트 번호에 유명한 서비스가 등록되어 있습니다. 대표적으로 22번 포트에는 SSH, 80에는 HTTP, 443에는 HTTPS가 할당되어 있습니다. 잘 알려진 포트에 서비스를 실행하려면 관리자 권한이 필요합니다. 따라서 클라이언트는 이 대역에서 실행 중인 서비스들은 관리자의 것이라고 신뢰할 수 있습니다.


- Request
----
GET
 
/index.html
 
HTTP/1.1
Host: naver.com
Connection: keep-alive
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.88 Safari/537.36

----


- Response 
----


HTTP/1.1
 
200 OK
Server: Apache/2.4.29 (Ubuntu)
Content-Length: 61
Connection: Keep-Alive
Content-Type: text/html

<!doctype html>
<html>
<head>
</head>
<body>
</body>
</html>

```







#### HTTP 통신을 요청할 때 HTTP 메시지 만들어서 보낸다. (Request)



![img](https://blog.kakaocdn.net/dn/NugL9/btrAyNqK4O9/FoIRByWOnCuEEuf2jyYQZK/img.png)











#### HTTP 통신을 응답할 때 HTTP 메시지 만들어서 보낸다. (Response)

![img](https://blog.kakaocdn.net/dn/b7Sv8d/btrAxMTfv0R/276eRVgDC4R2EMjA3yUAV1/img.png)








#  HTTP 메시지란?



![img](https://blog.kakaocdn.net/dn/btmZZr/btrAqTT9fot/0GD6UxZupacyUBo10ERVYK/img.png)



 

 

 

 

 

**HTTP 메시지란?**

 

HTTP 메시지에는 클라이언트가 전송하는 HTTP 요청, 그리고 서버가 반환하는 HTTP 응답이 있습니다. 기능과 세부 구조에서는 차이가 있지만, 크게 보면 이들은 HTTP 헤드와 바디로 구성된다는 공통점이 있습니다.

HTTP 헤드
HTTP 헤드의 각 줄은 CRLF로 구분되며, 첫 줄은 시작 줄(Start-line), 나머지 줄은 헤더(Header)라고 부릅니다. 헤드의 끝은 CRLF 한 줄로 나타냅니다.

시작 줄의 역할은 요청과 응답에서 큰 차이가 있습니다. 그러므로 이에 대해서는 조금 뒤에 각각을 자세히 기술하면서 설명하겠습니다.

헤더는 필드와 값으로 구성되며 HTTP 메시지 또는 바디의 속성을 나타냅니다. 하나의 HTTP 메시지에는 0개 이상의 헤더가 있을 수 있습니다.

HTTP 바디
HTTP 바디는 헤드의 끝을 나타내는 CRLF 뒤, 모든 줄을 말합니다. 클라이언트나 서버에게 전송하려는 데이터가 바디에 담깁니다.



# HTTP 요청





HTTP 요청은 서버에게 특정 동작을 요구하는 메시지입니다. 서버는 해당 동작이 실현 가능한지, 클라이언트가 그러한 동작을 요청할 권한이 있는지 등을 검토하고, 적절할 때만 이를 처리합니다.

시작 줄
HTTP 요청의 시작 줄은 메소드(Method), 요청 URI(Request-URI), 그리고 HTTP 버전으로 구성됩니다. 각각은 띄어쓰기로 구분합니다.

메소드는 URI가 가리키는 리소스를 대상으로, 서버가 수행하길 바라는 동작을 나타냅니다. HTTP 표준에 정의된 메소드는 8개가 있으나, 여기서는 비교적 자주 사용되는 GET과 POST 메소드만 설명하겠습니다.

먼저 GET은 리소스를 가져오라는 메소드입니다. 이용자가 브라우저에 웹 서버의 주소를 입력하거나 하이퍼링크를 클릭하면, 새로운 페이지를 렌더링하기 위해 리소스가 필요합니다. 이때 브라우저는 GET 요청을 서버에 전송하여 리소스를 받아옵니다. 반대로, POST는 리소스로 데이터를 보내라는 메소드입니다. 전송할 데이터는 보통 HTTP 바디에 포함됩니다. 로그인할 때 입력하는 ID와 비밀번호, 게시판에 작성하는 글 등이 POST로 서버에 보내집니다.

이 외에 요청 URI는 메소드의 대상을, HTTP 버전은 클라이언트가 사용하는 HTTP 프로토콜의 버전을 나타냅니다.



📎HTTP 요청의 메소드 및 URI에 대해 더 자세히 알고 싶다면, 표준 문서를 확인해 보자 
https://tools.ietf.org/pdf/rfc2616.pdf
[https://tools.ietf.org/html/rfc2616﻿](https://tools.ietf.org/html/rfc2616)

 

 

 



![img](https://blog.kakaocdn.net/dn/vffbz/btrAxGMr6H8/6xtBbK3bovFdmS4bEUYf30/img.png)




# HTTP 응답

 



HTTP 응답은 HTTP 요청에 대한 결과를 반환하는 메시지입니다. 요청을 수행했는지, 하지 않았는지, 안 했다면 이유는 무엇인지와 같은 상태 정보(Status), 그리고 클라이언트에게 전송할 리소스가 응답에 포함됩니다.

시작 줄
HTTP 응답의 시작 줄은 HTTP 버전, 상태 코드(Status Code), 그리고 처리 사유(Reason Phrase)로 구성됩니다. 각각은 띄어쓰기로 구분됩니다.

HTTP 버전은 서버에서 사용하는 HTTP 프로토콜의 버전을 나타냅니다. 그리고 상태 코드는 요청에 대한 처리 결과를 세 자릿수로 나타냅니다. HTTP 표준인 RFC 2616은 대략 40여개의 상태 코드를 정의하고 있는데, 각각은 첫 번째 자릿수에 따라 5개의 클래스로 분류됩니다. 처리 사유는 상태 코드가 발생한 이유를 짧게 기술한 것입니다.

 





 

> 
> 상태 코드
>
> 1xx
> 요청을 제대로 받았고, 처리가 진행 중임
>
> 2xx
> 요청이 제대로 처리됨
> 200: 성공
>
> 3xx
> 요청을 처리하려면, 클라이언트가 추가 동작을 취해야 함.
> 302: 다른 URL로 갈 것
>
> 4xx
> 클라이언트가 잘못된 요청을 보내어 처리에 실패했습니다.
> 400: 요청이 문법에 맞지 않음
> 403: 클라이언트가 리소스에 요청할 권한이 없음
> 404: 리소스가 없음
>
> 5xx
> 클라이언트의 요청은 유효하지만, 서버에 에러가 발생하여 처리에 실패했습니다.
> 500: 요청을 처리하다가 에러가 발생함
> 503: 서버가 과부하로 인해 요청을 처리할 수 없음



# HTTPS 란



HTTP의 응답과 요청은 평문으로 전달됩니다. 만약 누군가 이를 가로챈다면 중요한 정보가 유출될 수 있습니다. 예를 들어, 로그인할 때 전송한 POST 요청에는 대개 이용자의 ID와 비밀번호가 포함됩니다. 공격자가 중간에 이를 가로채면 이용자의 계정이 탈취당할 수 있습니다.

HTTPS(HTTP over Secure socket layer)는 TLS(Transport Layer Security) 프로토콜을 도입하여 이런 문제점을 보완합니다. TLS는 서버와 클라이언트 사이에 오가는 모든 HTTP 메시지를 암호화합니다. 공격자가 중간에 메시지를 탈취하더라도 이를 해석하는 것은 불가능하며, 결과적으로 HTTP 통신이 도청과 변조로부터 보호됩니다.


HTTPS가 제정된 초기에는 금융이나 정부 서비스와 같이 민감한 데이터를 취급하는 웹 서비스들 위주로 HTTPS가 사용되었습니다. 그러나 현재 개발되는 서비스들은 규모에 상관없이 HTTPS를 사용하는 추세입니다.

웹 서버의 URL이 http://로 시작되면 HTTP, https://로 시작되면 HTTPS 프로토콜을 사용합니다. 





 

![img](https://blog.kakaocdn.net/dn/Kc4zc/btrAxHEDFCy/gfSqKJUwySc3VjYUuPKbG0/img.png)







![img](https://blog.kakaocdn.net/dn/cDPplS/btrAs8X1tii/0lTdckcf7Hte9jndMIn6jk/img.png)







### **정리** 

 

> **HTTP(HyperText Transfer Protocol): 웹 서버와 클라이언트가 리소스를 교환하기 위해 사용하는 프로토콜. 클라이언트가 요청하면, 서버가 응답하는 방식.**
>
> **HTTP 메시지: HTTP 서버와 클라이언트가 교환하는 데이터. 헤드와 바디로 구성되며, 각 줄은 CRLF로 구분됨.**
>
> **헤드: 메시지에 대한 정보. 헤드의 끝에는 CRLF가 한 줄 있음.**
>
> **바디: 클라이언트가 서버에게, 또는 서버가 클라이언트에게 전달할 데이터**
>
> **HTTP 요청(Request): 클라이언트가 서버에게 특정 동작을 요청하는 메시지**
>
> **메소드(Method): 요청 URI가 가리키는 리소스에 대해, 서버가 수행했으면 하는 동작을 지정**
>
> **요청 URI(Request-URI): 메소드의 대상이 되는 리소스를 지정**
>
> **HTTP 응답(Response): 요청을 처리한 결과 및 이유, 그리고 클라이언트에 전송할 웹 리소스를 포함하는 메시지**
>
> **상태 코드(Status Code): 요청을 처리한 결과**
>
> **처리 사유(Reason Phrase): 상태 코드가 발생한 이유**
>
> **HTTPS(HTTP on Secure socket layer): TLS를 이용하여 HTTP의 약점을 보완한 프로토콜**

 

# web 이란?

인터넷을 기반으로 구현된 서비스 중 HTTP를 이용하여 정보를 공유하는 서비스를 웹이라 합니다. 여기서 정보를 제공하는 주체를 웹 서버 (Web Server), 정보를 받는 이용자를 웹 클라이언트 (Web Client) 라고 합니다. 식당에서 음식을 서빙하는 사람 (Server)과 음식을 주문하는 고객 (Client)의 관계로 생각하시면 됩니다. 여기서, HTTP란 웹상에서 서로 통신을 하기 위해 정해둔 일종의 규칙입니다. 

 

 

####  **웹의 발전과 웹 보안의 중요성**


초기 웹 서비스는 저장된 문서의 내용을 출력해 이용자에게 제공하는 간단한 서비스였습니다. 그런데 웹과 관련된 기술이 발전하면서 이제는 금융, 쇼핑, 협업 등 다양한 분야에서 이용자에게 편의를 주는 복잡한 서비스로 진화했습니다. 과거에는 단순히 정보를 보여주는 것에서 그쳤다면, 현재는 정보를 검색하고 직접 제품을 구매할 수 있도록 변화하였습니다.
이러한 웹의 발전은 우리의 일상을 많은 부분에서 바꿔놓았으며, 오프라인에서 이뤄지던 많은 상호작용이 현재는 디지털 형태로 변환되어 웹 서비스로 구현되고 있습니다.

한편, 웹에서 처리하는 정보 자산들이 많아짐에 따라 이들을 안전하게 보관하고 처리해야 할 필요성도 함께 증가하였습니다. 예를 들어, 고객이 물건을 구매하는 과정에서는 고객의 주소, 카드 번호 등의 정보들이 웹을 통해 서버로 전달됩니다. 만약 이 정보들이 안전하게 보호되지 않는다면 고객에게 심각한 피해를 야기할 수 있습니다. 그래서 웹을 통한 정보의 교환 과정에서 이러한 민감한 정보들이 유출되거나 악용되지 않도록 보호하는 웹 보안의 중요성이 대두하고 있습니다.

 

####  

####  **웹 서비스, 프론트엔드와 백엔드**

 

앞서 말한 것과 같이 웹 서비스는 다양한 기능을 수행하는 형태로 발전했습니다. 이전의 웹 서비스가 이용자가 요청하는 정보를 제공하기만 하는 수동적인 형태의 서비스였다면, 현재는 이용자의 요청을 해석하고 가공하여 필요한 정보와 기능을 제공하는 능동형 서비스에 가깝습니다. 예를 들어, 구글과 같은 검색 서비스는 이용자가 “검색어”라는 형태로 자신이 원하는 정보를 추상화해서 전달하면, 구글이 이를 해석하고 가공하여 필요한 정보를 제시합니다.

이런 서비스 구조에서, 이용자의 요청을 받는 부분을 프론트엔드 (Front-end), 요청을 처리하는 부분을 백엔드 (Back-end)라고 부릅니다. 호텔 프론트에 이런저런 서비스를 요청하면 뒤의 공간에서 고객 모르게 복잡한 일들이 벌어지는 것과 비슷합니다.

프론트엔드는 이용자에게 직접 보여지는 부분으로, 웹 리소스 (Web Resource)라는 것으로 구성됩니다. 페이지가 보여주고 있는 정보들은 모두 웹 리소스에 명시되어 있습니다. 페이지에 담기는 글, 글자들의 색깔과 모양, 배경 색상, 이미지의 크기나 투명도 등이 관련 언어로 적혀있습니다. 



# 웹 리소스란?



웹 리소스란, 웹에 갖춰진 정보 자산을 의미합니다.

웹 브라우저의 주소창에 https://www.naver.com/index.html 주소를 입력하면 [naver.com](https://www.naver.com/index.html) 에 존재하는 /index.html 경로의 리소스를 가져오라는 의미입니다. 모든 웹 리소스는 고유의 Uniform Resource Indicator (URI)를 가지며, 이를 이용하여 식별됩니다.

 

#### **웹의 프론트엔드를 구성하는 대표적인 웹 리소스들은 다음과 같습니다.**

**Hyper Text Markup Language (HTML)**

웹 문서의 뼈와 살을 담당합니다. 태그와 속성을 통한 구조화된 문서 작성을 지원합니다.

 

**Cascading Style Sheets (CSS)**

웹 문서의 생김새를 지정합니다. 웹 리소스들의 시각화 방법을 기재한 스타일 시트입니다. 글자의 색깔이나 모양, 배경 색상, 이미지의 크기나 위치 등을 CSS로 지정할 수 있습니다. 브라우저는 이를 참고하여 웹 문서를 시각화합니다.

 

**JavaScript (JS)**

웹 문서의 동작을 정의합니다. 이용자가 버튼을 클릭했을 때, 어떻게 반응할지, 이용자가 데이터를 입력하면 어디로 전송할지 등을 JS로 구현할 수 있습니다. JS는 이용자의 브라우저에서 실행되는데, 클라이언트가 실행하는 코드라고 하여 Client-Side Script라고도 부릅니다.

그 외

문서, 이미지, 동영상, 폰트 등이 있습니다. 



# 웹 클라이언트와 서버의 통신



> 웹 서비스의 통신 과정을 간략화하면 다음과 같습니다.


**(클라이언트) 이용자가 브라우저를 이용하여 웹 서버에 접속합니다.**
**(클라이언트) 브라우저는 이용자의 요청을 해석하여 HTTP 형식으로 웹 서버에 리소스를 요청합니다.**

**(서버) HTTP로 전달된 이용자의 요청을 해석합니다.**
**(서버) 해석한 이용자의 요청에 따라 적절한 동작을 합니다.**

리소스를 요청하는 것이라면, 이를 탐색합니다.

계좌 송금, 입금과 같은 복잡한 동작을 요구할 경우 내부적으로 필요한 연산을 처리합니다.

 

**(서버) 이용자에게 전달할 리소스를 HTTP 형식으로 이용자에게 전달합니다.**
**(클라이언트) 브라우저는 서버에게 응답받은 HTML, CSS, JS 등의 웹 리소스를 시각화하여 이용자에게 보여줍니다.**







------

#### **용어 정리** 

 

**통신:** 정보를 전하는 것. 현대에는 전화, 인터넷 등의 통신 수단을 이용하여 과거보다 시간과 공간의 제약을 받지 않고 이뤄짐.

**웹 :** 인터넷이라는 통신망을 활용하여 구현된 전 지구적 정보 공간
**웹 클라이언트:** 웹에서 정보를 요구하는 주체
**웹 서버:** 웹에서 정보를 제공하는 주체
**웹 리소스:** 웹 서버가 제공하는 정보 자원(e.g. HTML, Javascript, CSS 등)
**웹 서비스:** 웹 상에서 제공되는 서비스 (e.g. SNS, 온라인 쇼핑몰 등)


# 웹 브라우저란?



웹은 인터넷이라는 글로벌 네트워크 위에 구현되어 있으며, 정해진 프로토콜을 기반으로 통신합니다. 개발자가 아닌 일반 이용자가 이러한 규칙을 이해하고 인터넷을 사용하기는 매우 어렵습니다. 만약 그랬다면 지금처럼 SNS와 커뮤니티가 활성화되지는 못했을 것입니다. 20세기에 등장한 웹 브라우저는 서버와 HTTP 통신을 대신해주고, 수신한 리소스를 시각화하여 위와 같은 문제를 해결하였습니다.

웹 브라우저는 뛰어난 이용자 경험(User eXperience, UX)을 제공하는 소프트웨어 중 하나입니다. 이용자는 브라우저를 이용하여 쉽게 정보를 검색하고, 동영상을 보고, 파일을 내려받지만 내부에서 어떠한 연산이 일어나는지는 전혀 알지 못합니다.

브라우저를 통해 이용자가 주소창에 naver.com을 입력했을 때 웹 브라우저가 하게 되는 기본적인 동작을 나열한 것입니다.


**웹 브라우저의 주소창에 입력된 주소(naver.com)를 해석 (URL 분석)**
**naver.com에 해당하는 주소 탐색 (DNS 요청)**
**HTTP를 통해 naver.com 에 요청**
**naver.com의 HTTP 응답 수신**
**리소스 다운로드 및 웹 렌더링 (HTML, CSS, Javascript)**



 



![img](https://blog.kakaocdn.net/dn/bSBQOI/btrAxmA4tpK/AZYCKhXPfgXd8Vn4D9sdK0/img.jpg)



 

# URL 이란?



URL은 Uniform Resource Locator의 약자로, 웹에 있는 리소스의 위치를 표현하는 문자열입니다. 브라우저로 특정 웹 리소스에 접근할 때는, URL을 사용하여 이를 서버에게 요청합니다. 다음은 URL의 예시입니다.

URL은 Scheme, Authority (Userinfo, Host, Port), Path, Query, Fragment 등으로 구성됩니다. 이 중 자주 사용되는 요소는 다음과 같습니다.



 



![img](https://blog.kakaocdn.net/dn/snkvK/btrABZrcdJ0/b8Ex4DcmlCCRfpdGJ3uOUK/img.png)



 

 



![img](https://blog.kakaocdn.net/dn/dlhUy9/btrAxisAGQx/qZrZkywHp1KJww7xioCxIK/img.png)





URL에 대한 더 자세한 정보는 RFC 3986에서 확인할 수 있습니다.





# 웹 렌더링이란?





웹 렌더링(Web Rendering)은 서버로부터 받은 리소스를 이용자에게 시각화하는 행위를 말합니다. 서버의 응답을 받은 웹 브라우저는 리소스의 타입을 확인하고, 적절한 방식으로 이용자에게 전달합니다. 예를 들어, 서버로부터 HTML과 CSS를 받으면 브라우저는 HTML을 파싱하고 CSS를 적용하여 이용자에게 보여줍니다.

웹 렌더링은 웹 렌더링 엔진에 의해서 이뤄지는데, 브라우저별로 서로 다른 엔진을 사용합니다. 사파리는 웹킷(Webkit), 크롬은 블링크(Blink), 파이어폭스는 개코(Gecko) 엔진을 사용합니다. 각각의 엔진에 따라 렌더링 과정과 순서, 속도의 차이는 있지만, HTML을 파싱하고 시각화하여 이용자에게 보여주는 것은 같습니다.

오른쪽 모듈은 HTML, CSS, JS로 구현된 간단한 웹 페이지입니다. 이용자의 요청이 들어오면 서버는 웹 리소스들로 응답하고, 웹 브라우저는 이용자가 볼 수 있는 형태로 가공하여 화면에 출력합니다.

 

 

 

 



![img](https://blog.kakaocdn.net/dn/Zf4QD/btrAzvj6rhS/vdTKpySVLKJlwZPBOWiks1/img.png)



 

 

 

------

**키워드 정리** 

 

#### **웹 브라우저(Web Browser)**

웹 브라우저는 HTTP/S로 이용자와 웹 서버의
통신을 중개하며, 서버로부터 전달받은 다양한 웹 리소스들을 가공해
이용자에게 효과적으로 전달합니다. 
이용자가 다양한 프로토콜들을 알지 못해도 쉽게 웹을
사용할 수 있도록 도와줍니다.



#### **URL(Uniform Resource Locator)**

URL은 리소스의 위치를 나타내는 문자열로, 
브라우저는 이를 사용하여 서버에 특정 리소스를 요청할 수 있습니다.

####  

#### **DNS(Domain Name Server)**

#### Host의 도메인 이름을 IP로 변환하거나 IP를 도메인 이름으로 변환합니다.

####  



#### **웹 렌더링(Web Rendering)**

서버로부터 받은 리소스를 이용자에게
시각화하는 것을 말합니다.




## 쿠키 🍪

클라이언트의 IP 주소와 User-Agent는 매번 변경될 수 있는 고유하지 않은 정보일 뿐만 아니라, HTTP 프로토콜의 **Connectionless**와 **Stateless** 특징 때문에 웹 서버는 클라이언트를 기억할 수 없습니다

**Connectionless, Stateless** 특성을 갖는 HTTP에서 상태를 유지하기 위해 **쿠키(Cookie)**가 탄생했습니다. 쿠키는 Key와 Value로 이뤄진 일종의 단위로, 서버가 클라이언트에게 쿠키를 발급하면, 클라이언트는 서버에 요청을 보낼 때마다 쿠키를 같이 전송합니다. 서버는 클라이언트의 요청에 포함된 쿠키를 확인해 클라이언트를 구분할 수 있습니다.



- **Connectionless**: 하나의 요청에 하나의 응답을 한 후 연결을 종료하는 것을 의미합니다. 특정 요청에 대한 연결은 이후의 요청과 이어지지 않고 새 요청이 있을 때 마다 항상 새로운 연결을 맺습니다.
- **Stateless**: 통신이 끝난 후 상태 정보를 저장하지 않는 것을 의미합니다. 이전 연결에서 사용한 데이터를 다른 연결에서 요구할 수 없습니다.



## 용도



일반적으로 쿠키는 클라이언트의 정보 기록과 상태 정보를 표현하는 용도로 사용합니다.





### **정보 기록**

웹 서비스 사용 시 종종 등장하는 팝업 창에 “다시 보지 않기”, “7일 간 표시하지 않기” 버튼이 있는 것을 확인할 수 있습니다. 웹 서버는 각 클라이언트의 팝업 옵션을 기억하기 위해 쿠키에 해당 정보를 기록하고, 쿠키를 통해 팝업 창 표시 여부를 판단합니다. 과거에는 클라이언트의 정보를 저장하기 위해 쿠키가 종종 사용됐습니다. 쿠키는 서버와 통신할 때마다 전송되기 때문에 쿠키가 필요 없는 요청을 보낼 때 리소스 낭비가 발생할 수 있습니다. 최근에는 이러한 단점을 보완하기 위해 Modern Storage APIs를 통해 데이터를 저장하는 방식을 권장하고 있습니다.

### **상태 정보**

많은 웹 사이트에서는 회원 가입과 로그인을 통해 개개인에게 맞춤형 서비스를 제공합니다. 웹 서버에서는 수많은 클라이언트의 로그인 상태와 이용자를 구별해야 하는데, 이때 클라이언트를 식별할 수 있는 값을 쿠키에 저장해 사용합니다.







## 쿠키가 없는 통신

다음은 앞서 설명한 HTTP 통신의 특징을 간략하게 표현한 그림입니다. 서버는 요청을 보낸 클라이언트가 누군지 알 수 없기 때문에 현재 어떤 클라이언트와 통신하는지 알 수 없습니다.

![img](https://kr.object.ncloudstorage.com/dreamhack-content/page/c0effc0ace75e4c7b84b4eb464816ab63be7bc54edda4bcbd962e76b10ca09c0.png)







## 쿠키가 있는 통신

다음은 쿠키를 사용해 HTTP 통신이 이뤄지는 과정을 간략하게 표현한 그림입니다. 클라이언트는 서버에 요청을 보낼 때마다 쿠키를 포함하고, 서버는 해당 쿠키를 통해 클라이언트를 식별합니다.

![img](https://kr.object.ncloudstorage.com/dreamhack-content/page/72609b4b5f11e2ffa47919ee11049884214de0c7e3ace9020565981f375d95ee.png)





## 쿠키 변조

중국집 식당에서 탕수육 이벤트를 쿠폰을 발행해 방문할 때 마다 도장을 찍어주는 방식으로 진행하고 있습니다. 도장은 식당이 찍어주지만 쿠폰은 손님이 보관하기 때문에 손님은 쿠폰을 마음대로 할 수 있습니다. 만약 나쁜 마음을 품은 손님이 식당에서 사용하는 도장과 비슷한 도장을 구해 직접 쿠폰에 가짜 도장을 찍게 된다면 식당에서 이를 구분할 방법이 없습니다.

쿠키는 클라이언트의 브라우저에 저장되고 요청에 포함되는 정보입니다. 따라서, 아래 예시처럼 **악의적인 클라이언트는 쿠키 정보를 변조해 서버에 요청**을 보낼 수 있습니다. 만약 서버가 별다른 검증 없이 쿠키를 통해 이용자의 인증 정보를 식별한다면 아래 그림과 같이 공격자가 타 이용자를 사칭해 정보를 탈취할 수 있습니다.

![img](https://kr.object.ncloudstorage.com/dreamhack-content/page/9f2f1c1cd169b77f68fc1119803a8297c9251a33751ef32ec16ef32816f33023.png)
